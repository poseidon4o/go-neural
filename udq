[1mdiff --git a/src/problems/mario/mario.go b/src/problems/mario/mario.go[m
[1mindex 1c15e52..795e523 100644[m
[1m--- a/src/problems/mario/mario.go[m
[1m+++ b/src/problems/mario/mario.go[m
[36m@@ -16,6 +16,7 @@[m [mconst ([m
 	posY      NeuronName = iota[m
 	velY      NeuronName = iota[m
 	velX      NeuronName = iota[m
[32m+[m	[32mentType   NeuronName = iota[m
 	H1        NeuronName = iota[m
 	H2        NeuronName = iota[m
 	H3        NeuronName = iota[m
[36m@@ -134,6 +135,7 @@[m [mfunc NewMario(figCount int, size *util.Vector) *Mario {[m
 			*nets[c].Synapse(nrn(posY), r+nrn(H1)) = 0.0[m
 			*nets[c].Synapse(nrn(velX), r+nrn(H1)) = 0.0[m
 			*nets[c].Synapse(nrn(velY), r+nrn(H1)) = 0.0[m
[32m+[m			[32m*nets[c].Synapse(nrn(entType), r+nrn(H1)) = 0.0[m
 [m
 			// R to output[m
 			*nets[c].Synapse(r+nrn(R1), nrn(jump)) = 0.0[m
[36m@@ -239,13 +241,24 @@[m [mfunc (m *Mario) checkStep(c int) {[m
 }[m
 [m
 func (m *Mario) thnikStep(c int) {[m
[31m-	discreteX := float64(int(m.figures[c].fig.pos.X / float64(OBSTACLE_SPACING*BLOCK_SIZE)))[m
[32m+[m	[32mmax := m.lvl.size.X / float64(OBSTACLE_SPACING*BLOCK_SIZE)[m
[32m+[m	[32mdiscreteX := float64(int(m.figures[c].fig.pos.X/float64(OBSTACLE_SPACING*BLOCK_SIZE))) / max[m
 	m.figures[c].brain.Stimulate(nrn(posX), discreteX)[m
 [m
 	m.figures[c].brain.Stimulate(nrn(posY), m.figures[c].fig.pos.Y)[m
 	m.figures[c].brain.Stimulate(nrn(velX), m.figures[c].fig.vel.X)[m
 	m.figures[c].brain.Stimulate(nrn(velY), m.figures[c].fig.vel.Y)[m
 [m
[32m+[m	[32mvar entPos float64 = 0[m
[32m+[m	[32mif m.figures[c].fig.vel.X > 0 {[m
[32m+[m		[32mentPos = m.figures[c].fig.pos.X[m
[32m+[m	[32m} else {[m
[32m+[m		[32mentPos = m.figures[c].fig.pos.X - float64(OBSTACLE_SPACING*BLOCK_SIZE)[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32ment := float64(m.lvl.EntityAt(entPos)) / float64(LVL_NONE)[m
[32m+[m	[32mm.figures[c].brain.Stimulate(nrn(entType), ent)[m
[32m+[m
 	m.figures[c].brain.Step()[m
 [m
 	if m.figures[c].brain.ValueOf(nrn(jump)) > 0.9 {[m
[1mdiff --git a/src/problems/mario/physics.go b/src/problems/mario/physics.go[m
[1mindex 53dfb5b..77c8dcc 100644[m
[1m--- a/src/problems/mario/physics.go[m
[1m+++ b/src/problems/mario/physics.go[m
[36m@@ -6,6 +6,14 @@[m [mimport ([m
 	"math"[m
 )[m
 [m
[32m+[m[32mtype LevelEntity int[m
[32m+[m
[32m+[m[32mconst ([m
[32m+[m	[32mLVL_HOLE  LevelEntity = 1[m
[32m+[m	[32mLVL_PILAR LevelEntity = iota[m
[32m+[m	[32mLVL_NONE  LevelEntity = iota[m
[32m+[m[32m)[m
[32m+[m
 const G_CONST float64 = 9.8 * 150[m
 [m
 var G_FORCE util.Vector = util.Vector{[m
[36m@@ -56,9 +64,10 @@[m [mfunc (f *Figure) Move(dir int) {[m
 }[m
 [m
 type Level struct {[m
[31m-	size    util.Vector[m
[31m-	blocks  [][]*util.Vector[m
[31m-	figures []*Figure[m
[32m+[m	[32msize     util.Vector[m
[32m+[m	[32mblocks   [][]*util.Vector[m
[32m+[m	[32mfigures  []*Figure[m
[32m+[m	[32mentities []LevelEntity[m
 }[m
 [m
 func (l *Level) makeHole(c *int) {[m
[36m@@ -83,9 +92,10 @@[m [mfunc NewLevel(w, h int) *Level {[m
 	blockW := w / BLOCK_SIZE[m
 [m
 	lvl := &Level{[m
[31m-		size:    *util.NewVector(float64(w), float64(h)),[m
[31m-		blocks:  make([][]*util.Vector, blockW, blockW),[m
[31m-		figures: make([]*Figure, 0),[m
[32m+[m		[32msize:     *util.NewVector(float64(w), float64(h)),[m
[32m+[m		[32mblocks:   make([][]*util.Vector, blockW, blockW),[m
[32m+[m		[32mfigures:  make([]*Figure, 0),[m
[32m+[m		[32mentities: make([]LevelEntity, 0),[m
 	}[m
 [m
 	for c := 0; c < blockW; c++ {[m
[36m@@ -100,8 +110,10 @@[m [mfunc NewLevel(w, h int) *Level {[m
 		pr := c[m
 		if obs%OBSTACLE_SPACING == 0 {[m
 			if neural.Chance(0.5) {[m
[32m+[m				[32mlvl.entities = append(lvl.entities, LVL_HOLE)[m
 				lvl.makeHole(&c)[m
 			} else {[m
[32m+[m				[32mlvl.entities = append(lvl.entities, LVL_PILAR)[m
 				lvl.makeObstacle(&c)[m
 			}[m
 		} else {[m
[36m@@ -113,6 +125,14 @@[m [mfunc NewLevel(w, h int) *Level {[m
 	return lvl[m
 }[m
 [m
[32m+[m[32mfunc (l *Level) EntityAt(pos float64) LevelEntity {[m
[32m+[m	[32midx := int(pos/float64(BLOCK_SIZE*OBSTACLE_SPACING)) + 1[m
[32m+[m	[32mif idx < len(l.entities) && idx >= 0 {[m
[32m+[m		[32mreturn l.entities[idx][m
[32m+[m	[32m}[m
[32m+[m	[32mreturn LVL_NONE[m
[32m+[m[32m}[m
[32m+[m
 func (l *Level) toLevelCoords(pos *util.Vector) (int, int) {[m
 	return int(pos.X / float64(BLOCK_SIZE)), int(pos.Y / float64(BLOCK_SIZE))[m
 }[m
